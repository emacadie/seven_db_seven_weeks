As root, install postgresql-contrib

sudo -u postgres psql postgres
postgres=# create database book with owner ericm;
postgres=# grant all privileges on database book to ericm;
To make the extensions:
sudo -u postgres psql book -c "CREATE EXTENSION cube"
sudo -u postgres psql book -c "CREATE EXTENSION tablefunc"
sudo -u postgres psql book -c "CREATE EXTENSION dict_xsyn"
sudo -u postgres psql book -c "CREATE EXTENSION fuzzystrmatch"
sudo -u postgres psql book -c "CREATE EXTENSION pg_trgm"

I can run this as myself: 
psql book -c "SELECT '1'::cube;"

And do this to get to the db:
psql book

CREATE TABLE countries (
  country_code char(2) PRIMARY KEY,
  country_name text UNIQUE
);

This gives the output:
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "countries_pkey" for table "countries"
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "countries_country_name_key" for table "countries"
CREATE TABLE

INSERT INTO countries (country_code, country_name)
VALUES ('us','United States'), ('mx','Mexico'), ('au','Australia'),
('gb','United Kingdom'), ('de','Germany'), ('ll','Loompaland');

The output for that was:
INSERT 0 6
(I inserted 6 rows. What is the "?")

SELECT * FROM countries;
DELETE FROM countries WHERE country_code = 'll';
The output for that was
DELETE 1

CREATE TABLE cities (
  name text NOT NULL,
  postal_code varchar(9) CHECK (postal_code <> ''),
  country_code char(2) REFERENCES countries,
  PRIMARY KEY (country_code, postal_code)
);

book=> CREATE TABLE cities (
book(>   name text NOT NULL,
book(>   postal_code varchar(9) CHECK (postal_code <> ''),
book(>   country_code char(2) REFERENCES countries,
book(>   PRIMARY KEY (country_code, postal_code)
book(> );
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "cities_pkey" for table "cities"
CREATE TABLE
book=> \h
book=> INSERT INTO cities
book-> VALUES ('Toronto','M4C1B5','ca');
ERROR:  insert or update on table "cities" violates foreign key constraint "cities_country_code_fkey"
DETAIL:  Key (country_code)=(ca) is not present in table "countries".

book=> UPDATE cities
book-> SET postal_code = '97205'
book-> WHERE name = 'Portland';
UPDATE 1

SELECT cities.*, country_name
FROM cities INNER JOIN countries
ON cities.country_code = countries.country_code;

Here is a new one:
CREATE TABLE venues (
  venue_id SERIAL PRIMARY KEY,
  name varchar(255),
  street_address text,
  type char(7) CHECK ( type in ('public','private') ) DEFAULT 'public',
  postal_code varchar(9),
  country_code char(2),
  FOREIGN KEY (country_code, postal_code)
  REFERENCES cities (country_code, postal_code) MATCH FULL
);
NOTICE:  CREATE TABLE will create implicit sequence "venues_venue_id_seq" for serial column "venues.venue_id"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "venues_pkey" for table "venues"
CREATE TABLE

The check constraint is like an enum in MySQL. It must be one of the values provided. Is that in PostGres or one of the extensions?
Actually, look up "CHECK"

INSERT INTO venues (name, postal_code, country_code)
VALUES ('Crystal Ballroom', '97205', 'us');

SELECT v.venue_id, v.name, c.name
FROM venues v INNER JOIN cities c
ON v.postal_code=c.postal_code AND v.country_code=c.country_code;

INSERT INTO venues (name, postal_code, country_code)
VALUES ('Voodoo Donuts', '97205', 'us') RETURNING venue_id;

In MySQL, you would do "desc table venues"
In Postgres, it's "\d+ venues"

CREATE TABLE events (
  event_id SERIAL PRIMARY KEY,
  title varchar(255),
  starts timestamp, 
  ends timestamp,
  venue_id integer REFERENCES venues
  
);

book=> CREATE TABLE events (
book(>   event_id SERIAL PRIMARY KEY,
book(>   title varchar(255),
book(>   starts timestamp,
book(>   ends timestamp,
book(>   venue_id integer REFERENCES venues
book(> 
book(> );
NOTICE:  CREATE TABLE will create implicit sequence "events_event_id_seq" for serial column "events.event_id"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "events_pkey" for table "events"
CREATE TABLE


insert into events (title, starts, ends, venue_id)
values ('LARP Club', '2012-02-15 17:30', '2012-02-15 19:30', 2);
insert into events (title, starts, ends)
values ('April Fools Day', '2012-04-01 00:00', '2012-04-01 23:59');
insert into events (title, starts, ends)
values ('Christmas Day', '2012-12-25 00:00', '2012-12-25 23:59');

SELECT e.title, v.name
FROM events e JOIN venues v
ON e.venue_id = v.venue_id;

(same as inner join)

SELECT e.title, v.name
FROM events e LEFT JOIN venues v
ON e.venue_id = v.venue_id;

Using the "unique" keyword when creating a field also creates an index

You can also do this:
CREATE INDEX events_title
ON events USING hash (title);

Index for less-than, greater-than, equal-to, use b-tree
CREATE INDEX events_starts
ON events USING btree (starts);

The pg_class query to get the tables:
select * from pg_class where relnamespace = 2200 and not(relfrozenxid = 0);

alter table venues add column active boolean default true

select events.title, venues.country_code from events inner join venues on events.venue_id = venues.venue_id;
----
Day 2

INSERT INTO events (title, starts, ends, venue_id)
VALUES ('Moby', '2012-02-06 21:00', '2012-02-06 23:00', (
SELECT venue_id
FROM venues
WHERE name = 'Crystal Ballroom'
)
);

INSERT INTO events (title, starts, ends, venue_id)
values ('Wedding', '2012-02-26 21:00:00', '2012-02-26 23:00:00', 
(select venue_id from venues where name = 'Voodoo Donuts')),
('Dinner with Mom', '2012-02-26 18:00:00', '2012-02-26 20:30:00',
(select venue_id from venues where name = 'My Place')),
('Valentine''s Day', '2012-02-14 00:00:00', '2012-02-14 23:59:00', null);

SELECT count(title)
FROM events
WHERE title LIKE '%Day%';

SELECT min(starts), max(ends)
FROM events INNER JOIN venues
ON events.venue_id = venues.venue_id
WHERE venues.name = 'Crystal Ballroom';

SELECT venue_id, count(*)
FROM events
GROUP BY venue_id;

SELECT venue_id
FROM events
GROUP BY venue_id
HAVING count(*) >= 2 AND venue_id IS NOT NULL;

SELECT venue_id FROM events GROUP BY venue_id;

SELECT DISTINCT venue_id FROM events;

SELECT title, count(*) OVER (PARTITION BY venue_id) FROM events;
Not quite getting Window functions

BEGIN TRANSACTION;
DELETE FROM events;
ROLLBACK;
SELECT * FROM events;

BEGIN TRANSACTION;
UPDATE account SET total=total+5000.0 WHERE account_id=1337;
UPDATE account SET total=total-5000.0 WHERE account_id=45887;
END;

look at the file add_event.sql
SELECT add_event('House Party', '2012-05-03 23:00',
'2012-05-04 02:00', 'Run''s House', '97205', 'us');

Run this command outside the db:
createlang book --list

CREATE TABLE logs (
event_id integer,
old_title varchar(255),
old_starts timestamp,
old_ends timestamp,
logged_at timestamp DEFAULT current_timestamp
);

CREATE TRIGGER log_events
AFTER UPDATE ON events
FOR EACH ROW EXECUTE PROCEDURE log_event();

ALTER TABLE events
ADD colors text ARRAY;

UPDATE holidays SET colors = '{"red","green"}' where name = 'Christmas Day';

left off page 31, rules


#- EOF
